-- CREATING DATA BASES AND TABLES


-- DATA TYPES
	-- Boolean => True or False
	-- Character => char, varchar, and text
	-- Numeric => Integer and Floating-point number
	-- Temporal => Date, Time, TimeStamp and Interval
	-- UUID => Universaly Unique Identifiers
	-- Array => Stores an array of Strings, Numbers, etc. 
	-- JSON
	-- Hstore key-value pair
	-- Special types such as network address and geometric data
-- When creating a database and table, take your time to plan for long term storage. 
-- Remember you can always remove historical information you've decided you aren't using, but you can't go  back
-- in time to add information. 


-- PRIMARY and FOREIGN KEYS
-- A PRIMARY KEY is a column or a group of columns to identify a row uniquely in a table.
-- Primary Keys are also important since they allow ypu to easily discern what columns should be used 
-- for joining tables together. 
-- A FOREIGN KEY is a field or group of fields in a table that uniquely identifies a row in another table. 
-- A foreign key is defined in a table that references to the primary key of the other table.
-- The table that contains the FOREIGN KEY is called referencing table or child table.
-- The table to which the FOREIGN KEY referenes is called referenced table or parent table.
-- A table can have multiple FOREIGN KEYS depending on its relationship with other tables.
-- When creating tables and defining columns you can use constraints to define columns as being a primary key, or 
-- attaching a foreign key relationship to another table.

-- CONSTRAINTS
-- Constraints are the rules enforced on data columns on table.
-- These are used to prevent invalid data from being entered into the database.
-- This ensures the accuracy and reliability of the data in the database.
-- Constraints can be divided into two main categories.
	-- Column Constraints: Constrains the data in a column to adhere to certain conditions. 
	-- Table Constraints: Applied to the entire table rather than to an individual column.
-- The most common constraints used: 
	-- NOT NULL => Ensures that a column cannot have NULL value
	-- UNIQUE => Ensures that all values in a column are different
	-- PRIMARY KEY => Uniquely identifies each row/record in a database table
	-- FOREIGN KEY => Constrains data based on columns in other tables
	-- CHECK => Ensures that all values in a column satisfy certain conditions
	-- EXCLUSION => Ensures that if any two rows are compared on the specified colum or expression using
		-- the specified operator, not all of these comparisons will return TRUE.
	-- CHECK (condition) => To check a condition when inserting or updating data
	-- REFERENCES => to constrain the value stored in the column that must exist in a column in another table. 
	-- UNIQUE (column_list) => Forces the values stored in the columns listed inside the parentheses to be unique
	-- PRIMARY KEY (column_list) => Allows you to defines the primary key that consists of multiple columns. 


-- CREATE TABLE
-- SERIAL
	-- In PostgreSQL, a Sequence is a special kind of database object that generates a sequence of integers.
	-- A sequence is often used as the primary key column in a table. 
	-- It will create a sequence object and set the next value generated by the sequence as the default value for the column.
	-- This is perfect for a primary key, because it logs unique integer entries for you automatically upon insertion 
	-- If a row is later removed, the column with the SERIAL data type will NOT adjust, marking the fact that a row was removed from the sequene. 
CREATE DATABASE learning;
ALTER DATABASE learning OWNER TO postgres; 
\connect learning;
--USE learning;
CREATE TABLE players(player_id SERIAL PRIMARY KEY, age SMALLINT NOT NULL);	
CREATE TABLE account (
	user_id SERIAL PRIMARY KEY,  -- ERIAL is only used when declaring a PRIMARY KEY
	username VARCHAR(50) UNIQUE NOT NULL, 
	password VARCHAR(50) NOT NULL, 
	email VARCHAR(250) UNIQUE NOT NULL, 
	created_on TIMESTAMP NOT NULL, 
	last_login TIMESTAMP
);

CREATE TABLE job( 
	job_id SERIAL PRIMARY KEY,
	job_name VARCHAR(200) UNIQUE NOT NULL
);

CREATE TABLE account_job(
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
);


-- BASIC use of INSERT
-- Inserting from another table
	-- INSER INTO table1 (col1, col2) SELECT col3, col4 FROM table2;
-- SERIAL columns do not need to be provided a value.
INSERT INTO account (username, password, email, create_on) VALUES ('Antonio', 'password', 'Antonio@gmail.com', CURRENT_TIMESTAMP);
SELECT * FROM account; 

INSERT INTO job (job_name) VALUES ('Software Engineer');
SELECT * FROM job;

INSERT INTO acount_job(user_id, job_id, hire_date) VALUES (1, 1, CURRENT_TIMESTAMP); 


-- BASIC use of UPDATE
-- The UPDATE keyword allows for the changing of values of the columns in a table. 
UPDATE account SET last_login = CURRENT_TIMESTAMP WHERE last_login IS NULL;
-- Set based on another column
UPDATE account SET last_login = created_on;
-- "UPDATE JOIN" Using another table information to update the current table.
	-- UPDATE tableA SET col1 = tableB.col2 FROM tableB WHERE tableA.id = tableB.id;
-- Return affected rows. So you can see what are the rows affected. Otherwise you will only receive a success/error message;
UPDATE account SET last_login = created_on RETURNING account_id, last_login;
UPDATE account_job SET hire_date =  account.created_on FROM account WHERE account_job.user_id = account.user_id;
UPDATE account SET last_login = CURRENT_TIMESTAMP RETURNING email, created_on, last_login;


-- BASIC use of DELETE
-- You can delete rows based on their presence in other tables. 
	-- DELET FROM tableA USING tableB WHERE tableA.id = tableB.id
-- Deleter Evrything from a Table
	-- DELETE FROM tableA
-- Similar to UPDATE, you can aso add in a RETURNING call to return rows that were removed.
INSERT INTO job(job_name) VALUES 'QA';
DELETE FROM job WHERE job_name = 'QA' RETURNING job_id, job_name;


-- BASIC use of ALTER 
-- The ALTER clause allows for changes to an existing table structure, such as:
	-- Adding, dropping, or renaming columns.
	-- Chaning a column's data type. 
	-- Set DEFAULT values for a column.
	-- Add CHECK constraints. 
	-- Rename table.
-- ALTER constraints
	-- ALTER tableA ALTER COLUMN col1 SET TO NULL/ DROP DEFAULT/ ADD CONSTRAINT const_name;
CREATE TABLE information(
	info_id SERIAL PRIMARY KEY, 
	title VARCHAR(500) NOT NULL, 
	person VARCHAR(50) NOT NULL UNIQUE
);
SELECT * FROM information;
-- Rename Table 
ALTER TABLE information RENAME TO new_info;
SELECT * FROM new_info;
-- Rename Column
ALTER TABLE new_info RENAME COLUMN person TO people;
SELECT * FROM new_info;
-- Change the column constraints
-- SET to add a constraint
-- DROP to remove a constraint
INSERT INTO new_info(title) VALUES ('some new title'); -- Error
ALTER TABLE new_info ALTER COLUMN people DROP NOT NULL; 
INSERT INTO new_info(title) VALUES ('some new title'); -- Success


-- BASIC use of DROP
-- DROP allows for the complete removal of a column in a table. 
-- In PostgreSQL this will also automatically remove all of its indexes and constraints involving the column. 
-- However, it will mot remove columns used in views, triggers, or stored procedures without the additional CASCADE clause.
-- DROP a column. Check for existence to avoid error.
	-- ALTER TABLE tableA DROP COLUMN IF EXISTS col1;
ALTER TABLE new_info DROP COLUMN people;
ALTER TABLE new_info DROP IF EXISTS COLUMN people;


-- BASIC use of CHECK
-- The CHECK constraint allows you to create more customized constraints that adhere to a certain condition.
-- Such as making sure all inserted integer values fall below a certain threshold.
CREATE TABLE employees (
	employe_id SERIAL PRIMARY KEY,
	first_name VARCHAR(50) NOT NULL,
	last_name VARCHAR(50) NOT NULL,
	birthdate DATE CHECK (birthdate > '1900-01-01'),
	hire_date DATE CHECK (hire_date > birthdate),
	salary INTEGER CHECK (salary > 0)
);

INSERT INTO employees(first_name, last_name, birthdate, hire_date, salary) 
VALUES('Bruce', 'Wayne', '1899-11-03', '2010-01-01', -100); -- ERROR

INSERT INTO employees(first_name, last_name, birthdate, hire_date, salary) 
VALUES('Bruce', 'Wayne', '2000-11-03', '2024-01-01', 500); -- SUCCESS

SELECT * FROM employees;


-- !!!! ASSESSMENT !!!!
/*
Create a new database called "School" this database should have two tables: teachers and students.
The students table should have columns for student_id, first_name,last_name, homeroom_number, phone,email, and graduation year.
The teachers table should have columns for teacher_id, first_name, last_name,
homeroom_number, department, email, and phone.
The constraints are mostly up to you, but your table constraints do have to consider the following:
You must have a phone number to contact students in case of an emergency.
You must have ids as the primary key of the tables
Phone numbers and emails must be unique to the individual.
Once you've made the tables, insert a student named Mark Watney (student_id=1) who has a phone number of 777-555-1234 and doesn't have an email. He graduates in 2035 and has 5 as a homeroom number.
Then insert a teacher names Jonas Salk (teacher_id = 1) who as a homeroom number of 5 and is from the Biology department. His contact info is: jsalk@school.org and a phone number of 777-555-4321.
*/
CREATE TABLE students(
student_id serial PRIMARY KEY,
first_name VARCHAR(45) NOT NULL,
last_name VARCHAR(45) NOT NULL, 
homeroom_number integer,
phone VARCHAR(20) UNIQUE NOT NULL,
email VARCHAR(115) UNIQUE,
grad_year integer);

CREATE TABLE teachers(
teacher_id serial PRIMARY KEY,
first_name VARCHAR(45) NOT NULL,
last_name VARCHAR(45) NOT NULL, 
homeroom_number integer,
department VARCHAR(45),
email VARCHAR(20) UNIQUE,
phone VARCHAR(20) UNIQUE);

INSERT INTO students(first_name,last_name, homeroom_number,phone,grad_year)VALUES ('Mark','Watney',5,'7755551234',2035);

INSERT INTO teachers(first_name,last_name, homeroom_number,department,email